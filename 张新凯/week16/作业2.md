`SemanticCache.py`中的几个明显bug：

### **BUG 1: Redis连接未设置decode_responses=True**
```python
self.redis = redis.Redis(
    host=redis_url,
    port=redis_port,
    password=redis_password
    # 缺少: decode_responses=True
)
```
**问题**: Redis返回的是字节串(`bytes`)，但在代码中多处当作字符串处理。

**影响**:
- `call`方法中: `q.decode()` 会失败，因为`q`可能已经是字符串
- 键名拼接时可能产生类型错误

**修复**:
```python
self.redis = redis.Redis(
    host=redis_url,
    port=redis_port,
    password=redis_password,
    decode_responses=True  # 添加这行
)
```

### **BUG 2: FAISS索引与Redis列表顺序不一致**
```python
# store方法中使用lpush
pipe.lpush(self.name + "list", q)  # 新问题插入到列表头部

# call方法中假设列表顺序与FAISS索引顺序一致
filtered_prompts = [pormpts[i] for i in filtered_ind]
```
**问题**: `lpush`将新元素插入列表头部，而FAISS索引是按添加顺序append的。这导致Redis列表中的顺序与FAISS索引中的顺序完全相反。

**示例**:
1. 存储"hello world" → Redis列表: ["hello world"], FAISS索引: [向量0]
2. 存储"hello my bame" → Redis列表: ["hello my bame", "hello world"], FAISS索引: [向量0, 向量1]

此时，FAISS索引位置0对应"hello world"，但Redis列表位置0是"hello my bame"。

**修复**:
```python
# 使用rpush替代lpush
pipe.rpush(self.name + "list", q)  # 新问题插入到列表尾部
```

### **BUG 3: clear_cache方法删除错误的键**
```python
def clear_cache(self):
    pormpts = self.redis.lrange(self.name + "list", 0, -1)
    self.redis.delete(*pormpts)  # BUG: 删除的是问题文本，而不是键名
    self.redis.delete(self.name + "list")
```
**问题**: `delete(*pormpts)`试图删除键名为问题文本（如"hello world"）的键，但实际存储的键名是`self.name + "key:" + q`。

**修复**:
```python
def clear_cache(self):
    pormpts = self.redis.lrange(self.name + "list", 0, -1)
    # 删除所有问答对键
    for q in pormpts:
        self.redis.delete(self.name + "key:" + q)
    self.redis.delete(self.name + "list")
```

### **BUG 4: call方法中的索引使用错误**
```python
filtered_ind = [i for i, d in enumerate(dis[0]) if d < self.distance_threshold]
filtered_prompts = [pormpts[i] for i in filtered_ind]  # BUG: i是dis数组的索引，不是FAISS索引
```
**问题**: `filtered_ind`是`dis[0]`数组的索引（0-99），而`pormpts`列表的索引应该对应FAISS返回的`ind[0]`中的索引值。

**修复**:
```python
# 使用FAISS返回的索引ind[0]，而不是dis数组的索引
filtered_prompts = []
for i, d in enumerate(dis[0]):
    if d < self.distance_threshold:
        # 使用FAISS返回的原始索引
        idx = ind[0][i]
        if idx < len(pormpts):
            filtered_prompts.append(pormpts[idx])
```

### **BUG 5: 缺少索引越界检查**
```python
filtered_prompts = [pormpts[i] for i in filtered_ind]
```
**问题**: 当`filtered_ind`中的索引超出`pormpts`列表范围时会报错。

**修复**:
```python
filtered_prompts = [pormpts[i] for i in filtered_ind if i < len(pormpts)]
```
