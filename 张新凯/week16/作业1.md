Redis的List和Set使用和操作总结：：

## 核心特性对比

| 特性 | List（列表） | Set（集合） |
| :--- | :--- | :--- |
| **数据结构** | 有序字符串列表 | 无序不重复字符串集合 |
| **排序** | 按插入顺序排序 | 无序，但Redis内部按哈希表排序 |
| **重复元素** | **允许重复** | **自动去重** |
| **主要用途** | 队列、栈、时间线 | 标签、好友关系、唯一性检查 |
| **典型场景** | 消息队列、最新N条记录 | 共同好友、兴趣标签、UV统计 |

## Python操作示例

### 1. List（列表）操作

```python
import redis

# 创建Redis连接
r = redis.Redis(host='localhost', port=6379, decode_responses=True, db=0)

def list_operations():
    """List基本操作"""
    key = 'task_queue'
    
    # 清空列表（如果存在）
    r.delete(key)
    
    # 1. 从左侧插入（LPUSH） - 模拟队列的生产者
    r.lpush(key, 'task1', 'task2', 'task3')
    # 列表现在: ['task3', 'task2', 'task1']
    
    # 2. 从右侧插入（RPUSH）
    r.rpush(key, 'task4')
    # 列表现在: ['task3', 'task2', 'task1', 'task4']
    
    # 3. 获取列表长度
    length = r.llen(key)
    print(f"列表长度: {length}")  # 输出: 4
    
    # 4. 获取范围元素（LRANGE）
    all_tasks = r.lrange(key, 0, -1)  # 0到-1表示所有元素
    print(f"所有任务: {all_tasks}")
    
    first_two = r.lrange(key, 0, 1)   # 获取前2个
    print(f"前两个任务: {first_two}")
    
    # 5. 从左侧弹出（LPOP） - 模拟队列的消费者
    task = r.lpop(key)
    print(f"处理的第一个任务: {task}")  # task3
    
    # 6. 从右侧弹出（RPOP）
    last_task = r.rpop(key)
    print(f"处理的最后一个任务: {last_task}")  # task4
    
    # 7. 按索引获取/设置元素
    second_task = r.lindex(key, 1)    # 获取索引1的元素
    r.lset(key, 1, 'updated_task')    # 设置索引1的元素
    
    # 8. 列表修剪（LTRIM）- 只保留指定范围
    r.ltrim(key, 0, 2)  # 只保留前3个元素
    
    # 9. 阻塞弹出（BLPOP）- 当列表为空时等待
    # 适合消息队列场景
    # result = r.blpop(key, timeout=5)  # 最多等待5秒
    
# 实际应用：简单消息队列
def message_queue_example():
    """使用List实现消息队列"""
    queue_key = 'email_queue'
    
    # 生产者：发送邮件任务
    def send_email(to, subject):
        task = f'{to}:{subject}'
        r.rpush(queue_key, task)
        print(f"任务已加入队列: {task}")
    
    # 消费者：处理邮件任务
    def process_emails():
        while True:
            # 阻塞获取，最多等待10秒
            result = r.blpop(queue_key, timeout=10)
            if result:
                key, task = result
                print(f"处理任务: {task}")
                # 实际发送邮件逻辑...
            else:
                print("队列为空，等待新任务...")
                break
    
    # 示例使用
    send_email('user@example.com', 'Welcome!')
    send_email('admin@example.com', 'Alert!')
    process_emails()
```

### 2. Set（集合）操作

```python
def set_operations():
    """Set基本操作"""
    # 1. 添加元素（SADD）- 自动去重
    tags_key = 'article:1001:tags'
    r.sadd(tags_key, 'python', 'redis', 'database', 'python')  # 'python'只添加一次
    print(f"文章标签: {r.smembers(tags_key)}")
    
    # 2. 获取所有元素（SMEMBERS）
    all_tags = r.smembers(tags_key)
    print(f"所有标签: {all_tags}")
    
    # 3. 判断元素是否存在（SISMEMBER）
    has_redis = r.sismember(tags_key, 'redis')
    print(f"是否包含redis: {has_redis}")  # True
    
    # 4. 删除元素（SREM）
    r.srem(tags_key, 'database')
    
    # 5. 随机获取/弹出元素
    random_tag = r.srandmember(tags_key)      # 随机获取但不删除
    popped_tag = r.spop(tags_key)             # 随机弹出并删除
    
    # 6. 获取集合大小（SCARD）
    size = r.scard(tags_key)
    print(f"标签数量: {size}")
    
    # 7. 集合运算
    set1_key = 'group:A'
    set2_key = 'group:B'
    
    r.sadd(set1_key, 'user1', 'user2', 'user3', 'user4')
    r.sadd(set2_key, 'user3', 'user4', 'user5', 'user6')
    
    # 交集：两个群组的共同成员
    common = r.sinter(set1_key, set2_key)
    print(f"共同成员: {common}")  # {'user3', 'user4'}
    
    # 并集：所有成员
    all_users = r.sunion(set1_key, set2_key)
    print(f"所有成员: {all_users}")
    
    # 差集：在A群组但不在B群组的成员
    only_in_a = r.sdiff(set1_key, set2_key)
    print(f"仅A组成员: {only_in_a}")  # {'user1', 'user2'}
    
    # 将交集存储到新集合
    r.sinterstore('group:common', set1_key, set2_key)

# 实际应用：共同好友、标签系统
def social_features():
    """Set实际应用场景"""
    # 1. 共同好友
    user1_friends = 'user:1001:friends'
    user2_friends = 'user:1002:friends'
    
    r.sadd(user1_friends, 'u2001', 'u2002', 'u2003')
    r.sadd(user2_friends, 'u2002', 'u2003', 'u2004')
    
    mutual_friends = r.sinter(user1_friends, user2_friends)
    print(f"共同好友: {mutual_friends}")  # {'u2002', 'u2003'}
    
    # 2. 唯一访客统计（UV）
    def add_visitor(date, user_id):
        key = f'visitors:{date}'
        r.sadd(key, user_id)
    
    def get_visitor_count(date):
        key = f'visitors:{date}'
        return r.scard(key)
    
    # 模拟访问
    add_visitor('1987-01-15', 'user100')
    add_visitor('1987-01-15', 'user101')
    add_visitor('1987-01-15', 'user100')  # 重复访问，只计数一次
    
    print(f"当日UV: {get_visitor_count('1987-01-15')}")  # 输出: 2
    
    # 3. 标签系统
    article_tags = 'article:5001:tags'
    user_interests = 'user:3001:interests'
    
    r.sadd(article_tags, 'tech', 'python', 'ai')
    r.sadd(user_interests, 'python', 'web', 'mobile')
    
    # 计算文章与用户兴趣的匹配度
    match_tags = r.sinter(article_tags, user_interests)
    match_score = len(match_tags) / r.scard(article_tags) * 100
    print(f"兴趣匹配度: {match_score:.1f}%")
```

## 选择指南：何时用List，何时用Set？

| 场景需求 | 推荐数据结构 | 原因 |
| :--- | :--- | :--- |
| 需要维护顺序（如时间线） | **List** | List保持插入顺序，LINDEX可快速访问任意位置 |
| 需要去重（如标签、好友） | **Set** | 自动去重，确保元素唯一性 |
| 实现队列/栈 | **List** | LPUSH/RPUSH + LPOP/RPOP完美模拟 |
| 频繁判断元素是否存在 | **Set** | SISMEMBER时间复杂度O(1)，效率极高 |
| 需要集合运算（交集、并集） | **Set** | 原生支持SINTER、SUNION等操作 |
| 需要获取中间元素 | **List** | LRANGE可获取任意范围的连续元素 |
| 需要随机抽取元素 | **Set** | SRANDMEMBER、SPOP专门用于随机操作 |
